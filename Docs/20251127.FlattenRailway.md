# Flatten Railway: Railway-Oriented Programming Vision for Align2.fs

**Date**: 2025-11-27
**Status**: Design Vision
**Goal**: Transform nested imperative code into flat, composable railway-oriented pipeline

## The Problem

The current `Align2.fs` implementation (lines 1348-1619) has deeply nested pattern matching that creates a "pyramid of doom":

```fsharp
async {
    match validateAlignOptions opts with          // ← Level 1
    | Error err -> return 1
    | Ok () ->
        match calValidationResult with            // ← Level 2
        | Error err -> return 1
        | Ok () ->
            match resolveInputFiles with          // ← Level 3
            | Error err -> return 1
            | Ok files ->
                let! mastersResult = loadCalibrationMasters opts
                match mastersResult with          // ← Level 4
                | Error err -> return 1
                | Ok masters ->
                    match analyzeReference with   // ← Level 5
                    | Error err -> return 1
                    | Ok refData ->
                        match opts.OutputMode with  // ← Level 6
                        (* ... *)
}
```

**Six levels of nesting** for what should be a linear pipeline.

## The Vision

Transform this into **flat, railway-oriented composition** where:

1. **Each step is uniform** - no artificial groupings like "preprocessing" vs "processing"
2. **Errors compose naturally** - each step contributes one error case to a flat sum type
3. **Optional steps are explicit** - skip behavior is `Ok(input)`, not suppressed errors
4. **Computation expression eliminates nesting** - `let!` chains steps cleanly

## Core Principles

### Principle 1: All Steps Are Equal

Every step in the pipeline is just a transformation:

```
load → calibrate → bin → detect → match → distort → transform → save
```

There's no reason to group `calibrate` and `bin` as special "preprocessing" when `detect`, `match`, and `distort` are equally just steps in the same railway. **All of this is processing.**

### Principle 2: Flat Error Composition

Error types should compose **without artificial nesting**:

```fsharp
/// Flat error type - each step is equal
type PipelineError =
    | LoadFailed of string
    | CalibrationFailed of Algorithms.Calibration.CalibrationError
    | BinningFailed of Algorithms.Binning.BinningError
    | DetectionFailed of string
    | MatchingFailed of string
    | DistortionFailed of string
    | TransformFailed of string
    | SaveFailed of string
```

**Not** wrapped in artificial hierarchies like:
```fsharp
// ❌ Don't do this - artificial grouping
type PipelineError =
    | PreprocessingError of PreprocessingError  // Groups calibrate + bin
    | ProcessingError of ProcessingError        // Groups everything else
```

### Principle 3: Compose Error Types from Modules

Don't wrap errors in strings—**preserve type information**:

```fsharp
// ✅ Good - preserves the error type!
| BinningFailed of Algorithms.Binning.BinningError

// ❌ Bad - loses type information!
| BinningFailed of string
```

Use `Result.mapError` to lift child errors into parent errors:

```fsharp
Binning.validateConfig config           // Returns: Result<unit, BinningError>
|> Result.mapError BinningFailed        // Returns: Result<unit, PipelineError>
```

### Principle 4: Uniform Step Pattern

Every step follows the **same pattern**:

```fsharp
/// Step: <name> (or skip)
let stepName
    (config: Config option)     // Configuration (None = skip)
    (input: InputType)          // Data from previous step
    : Result<OutputType, PipelineError> =

    match config with
    | None -> Ok input          // Skip track: pass through unchanged
    | Some cfg ->
        result {
            // Validate
            do! validateSomething cfg
                |> Result.mapError ErrorConstructor

            // Transform
            let output = doWork cfg input

            // Return
            return output
        }
```

**Key characteristics:**
- If not configured: `Ok(input)` (skip = identity)
- If configured: validate → transform → return
- Errors use `Result.mapError` to lift into `PipelineError`

## Example: Small Pipeline (calibrate → bin)

### Step Definitions

```fsharp
// Using FsToolkit.ErrorHandling for CE builders
open FsToolkit.ErrorHandling

/// Step: Calibrate (or skip)
let calibrate
    (masters: (MasterFrames * CalibrationConfig) option)
    (img: ImageData)
    : Result<ImageData, PipelineError> =

    match masters with
    | None -> Ok img  // Skip: no calibration configured
    | Some (m, cfg) ->
        try
            let result = calibratePixels img.Pixels m cfg
            Ok { img with Pixels = result.CalibratedPixels }
        with ex ->
            Error (CalibrationFailed (Algorithms.Calibration.LoadFailed ("calibration", ex.Message)))

/// Step: Bin (or skip)
let bin
    (binFactor: int option)
    (binMethod: BinningMethod)
    (img: ImageData)
    : Result<ImageData, PipelineError> =

    match binFactor with
    | None -> Ok img  // Skip: no binning configured
    | Some factor ->
        result {
            let config = { Factor = factor; Method = binMethod }

            // Validate config - lift BinningError into PipelineError
            do! Binning.validateConfig config
                |> Result.mapError BinningFailed

            // Validate dimensions - lift BinningError into PipelineError
            do! Binning.validateDimensions img.Width img.Height img.Channels factor
                |> Result.mapError BinningFailed
                |> Result.map ignore

            // Apply binning
            let result = binPixels img.Pixels img.Width img.Height img.Channels config

            return {
                Pixels = result.BinnedPixels
                Width = result.NewWidth
                Height = result.NewHeight
                Channels = img.Channels
            }
        }
```

### Pipeline Composition (Computation Expression)

```fsharp
/// Process image through calibration and binning
let preprocessImage
    (masters: (MasterFrames * CalibrationConfig) option)
    (binFactor: int option)
    (binMethod: BinningMethod)
    (img: ImageData)
    : Result<ImageData, PipelineError> =

    result {
        let! calibrated = calibrate masters img
        let! binned = bin binFactor binMethod calibrated
        return binned
    }
```

**Result**: Flat, readable, composable. No nested matches!

## Example: Full Pipeline

### Complete Pipeline Composition

```fsharp
/// Process a single file through the complete alignment pipeline
let processFile
    (inputPath: string)
    (masters: (MasterFrames * CalibrationConfig) option)
    (binFactor: int option)
    (binMethod: BinningMethod)
    (detConfig: DetectionConfig)
    (matchConfig: MatchingConfig option)
    (distConfig: DistortionConfig option)
    (transConfig: TransformConfig option)
    : Async<Result<ProcessedData, PipelineError>> =

    asyncResult {
        let fileName = Path.GetFileName inputPath

        // Each step feeds the next - no special groupings!
        let! img = load inputPath
        let! calibrated = calibrate masters img |> AsyncResult.ofResult
        let! binned = bin binFactor binMethod calibrated |> AsyncResult.ofResult
        let! detected = detect detConfig binned |> AsyncResult.ofResult
        let! matched = matchToRef matchConfig fileName detected |> AsyncResult.ofResult
        let! distorted = distort distConfig matched |> AsyncResult.ofResult
        let! transformed = transform transConfig distorted |> AsyncResult.ofResult

        return {
            Detected = detected
            Matched = matched
            Distorted = distorted
            Transformed = transformed
        }
    }
```

**Characteristics:**
- **Flat**: Single level of indentation
- **Linear**: Reads top-to-bottom like the conceptual pipeline
- **Composable**: Each step is independent and testable
- **Type-safe**: Compiler enforces correct data flow
- **Error handling**: Any step can fail, railway short-circuits

### Why Computation Expression Over Operators?

**Operator approach** (too noisy):
```fsharp
load inputPath
|> AsyncResult.bind (calibrate masters >> AsyncResult.ofResult)
|> AsyncResult.bind (bin binFactor binMethod >> AsyncResult.ofResult)
|> AsyncResult.bind (detect detConfig >> AsyncResult.ofResult)
// Repeated "AsyncResult.bind" and "AsyncResult.ofResult" noise
```

**Computation expression** (clean):
```fsharp
asyncResult {
    let! img = load inputPath
    let! calibrated = calibrate masters img |> AsyncResult.ofResult
    let! binned = bin binFactor binMethod calibrated |> AsyncResult.ofResult
    let! detected = detect detConfig binned |> AsyncResult.ofResult
    // Clear data flow, minimal noise
}
```

The computation expression eliminates the repeated `AsyncResult.bind` noise while maintaining clarity.

## Benefits of This Approach

### 1. Composability
Each step is a pure function that can be:
- Tested independently
- Reused in different pipelines
- Composed in different orders

### 2. Type Safety
The compiler enforces:
- Correct data flow between steps
- All error cases are handled
- No forgetting to check Results

### 3. Readability
Pipeline reads like plain English:
```fsharp
let! img = load inputPath
let! calibrated = calibrate masters img
let! binned = bin binFactor binMethod calibrated
```

vs. nested imperative:
```fsharp
match loadImage with
| Error -> ...
| Ok img ->
    match calibrate with
    | Error -> ...
    | Ok calibrated ->
        (* ... *)
```

### 4. Error Propagation
Railway automatically short-circuits on first error:
- If `load` fails, subsequent steps don't run
- Error information is preserved (no string wrapping)
- Caller can pattern match on specific error cases

### 5. Optional Steps Are Explicit
Skip behavior is clear:
```fsharp
match masters with
| None -> Ok img           // Explicit skip
| Some m -> calibrate m img  // Explicit process
```

vs. suppressed errors:
```fsharp
try
    calibrate img
catch ex ->
    Log.Warning("Skipping calibration")
    img  // Silently returns original
```

## Implementation Notes

### Required Infrastructure

1. **Computation Expressions**:
   - `result` CE for `Result<'T, 'E>` composition
   - `asyncResult` CE for `Async<Result<'T, 'E>>` composition
   - Using FsToolkit.ErrorHandling (already a project dependency)

2. **Error Types**:
   - Each module defines its own error type
   - Parent modules compose child errors (no string wrapping)
   - All errors have proper `ToString()` for logging

3. **Helper Functions**:
   - FsToolkit.ErrorHandling provides all needed combinators
   - `Result.mapError` to lift child errors into parent errors

### Migration Strategy

This document captures the **desired end state**, not the migration path. The refactoring should happen incrementally:

1. Start with small functions (`calibrate`, `bin`)
2. Expand to larger pipelines (`preprocessImage`)
3. Eventually refactor the full `run` function

## Non-Goals

This vision document is **not** about:
- ❌ Sharing code between `Align.fs` and `Align2.fs` (Align2 replaces Align entirely)
- ❌ Extracting common CLI infrastructure to a shared module
- ❌ Changing the actual algorithms or business logic
- ❌ Changing the command-line interface or user-facing behavior

## Success Criteria

The refactoring is complete when:

✅ No function has more than 2 levels of pattern match nesting
✅ The main `run` function uses `asyncResult` CE with flat `let!` bindings
✅ All error types compose child module errors (no string wrapping)
✅ Each pipeline step follows the uniform pattern
✅ Optional steps explicitly return `Ok(input)` when skipped
✅ The code reads like the conceptual pipeline: `load → calibrate → bin → detect → match → distort → transform → save`

## Conclusion

Railway-oriented programming transforms nested imperative code into **flat, composable pipelines**. The key insights:

- **All steps are equal** - no artificial hierarchies
- **Errors compose naturally** - use sum types, not strings
- **Skip = identity** - `Ok(input)` is explicit
- **Computation expressions eliminate nesting** - `let!` chains cleanly

The result is code that is easier to read, test, maintain, and extend.

---

## Refactoring Plan

### Phase 1: Infrastructure (Zero Breaking Changes)
Add computation expression builders and error types without modifying existing code.

**Actions:**
- Add `result` and `asyncResult` computation expressions at top of file
- Define flat `PipelineError` discriminated union
- Add `AsyncResult` helper module with `ofResult` and `ofAsync`

**Compile:** ✓ No changes to existing functions

### Phase 2: Convert Pure Pipeline Steps
Convert calibrate/bin to Result-based signatures.

**Actions:**
- Change `calibrate: ... -> ImageData -> ImageData` to `... -> ImageData -> Result<ImageData, PipelineError>`
- Change `bin: ... -> ImageData -> ImageData` to `... -> ImageData -> Result<ImageData, PipelineError>`
- Update `preprocessImage` to use `result` CE with `let!` chains
- Remove `Log.Warning` fallbacks, make errors explicit

**Compile:** Breaking changes to `preprocessImage`, fix callsites in process functions

**Critical:** Fix all callsites that use `|> calibrate` or `|> bin` to handle Result

### Phase 3: Convert Image I/O
Convert loading/saving to proper error types.

**Actions:**
- `loadImage` already returns `Result`, keep as-is
- Change `writeOutputFile` from `unit` return to `Result<unit, string>`
- Update error handling in all `writeOutputFile` calls

**Compile:** Breaking changes in all process functions

### Phase 4: Fix Option-Returning Functions
Change Algorithms.Alignment.fs to return Result instead of option.

**Actions in Algorithms/Alignment.fs:**
- `matchToReference: ... -> MatchedImage option` → `Result<MatchedImage, string>`
- `transform: ... -> ImageData option` → `Result<ImageData, string>`
- Preserve error messages instead of returning None

**Actions in Commands/Align2.fs:**
- Replace option pattern matches with Result pattern matches
- Remove generic "Failed to..." log messages
- Propagate actual error messages from Alignment module

**Compile:** Breaking changes in all callsites (detect/match/align/distortion modes)

**Critical:** Touches Algorithms module, affects Align2.fs callsites

**Note:** `detect`, `calibratePixels`, `binPixels` return plain values (never fail), no changes needed

### Phase 5: Convert Process Functions to Result
Convert all process* functions to return typed errors and update callsites.

**Actions:**
- Change return type from `Async<bool>` to `Async<Result<unit, PipelineError>>`
- Use `asyncResult` CE to flatten nested matches in each process function
- Update all callsites in `run` function to handle Result
- Keep high-level structure intact (parallel processing, etc.)

**Compile:** ✓ All process functions converted, all callsites updated

### Phase 6: Final Cleanup and Flattening
Remove artificial groupings and flatten remaining nested code.

**Actions:**
- Eliminate `preprocessImage` function - compose pipeline steps directly
- Flatten validation in `run` function
- Extract validation steps into helper functions if needed
- Clean up any remaining nested matches

**Compile:** ✓ Final structure flat and clean

### Phase 7: Cleanup ✅ COMPLETE
Remove dead code, section dividers, and unnecessary comments.

**Actions:**
- ✅ Remove `ProcessingResult` type (already removed in earlier phases)
- ✅ Ensure all `PipelineError` cases have proper `ToString()`
- ✅ Remove all section dividers (------------)
- ✅ Remove pipeline flow comment
- ✅ Remove benefits commentary block

**Compile:** ✓ All changes successful, code compiles

### Phase 8: Create RunError Type
Add unified error type for the run function to support flat composition.

**Actions:**
- Create `RunError` discriminated union with cases for each validation/processing step
- Add proper `ToString()` implementation for all cases
- Error cases should include:
  - `ValidationFailed of AlignValidationError`
  - `CalibrationValidationFailed of Algorithms.Calibration.CalibrationError`
  - `InputResolutionFailed of InputValidationError`
  - `MasterLoadFailed of string`
  - `ReferenceAnalysisFailed of PipelineError`
  - `InsufficientStars of found: int * required: int`
  - `ProcessingFailed of string`

**Compile:** ✓ Type added, no breaking changes yet

### Phase 9: Extract Validation Helper Functions
Break out validation logic from run function into small, composable helpers.

**Actions:**
- Create `validateCalibrationConfig: AlignOptions -> Result<unit, CalibrationError>`
  - Extract calibration config validation from run function
  - Return `Ok ()` if no calibration configured
  - Otherwise validate using `Calibration.validateConfig`
- Create `validateReferenceStars: int -> Result<unit, string>`
  - Check if star count >= 10
  - Return proper error message if insufficient
- Create `resolveReferenceFile: string[] -> AlignOptions -> string`
  - Extract reference file resolution logic
  - Handle auto-reference (with warning for now)
  - Return first file as fallback

**Compile:** ✓ New functions added, run function still works unchanged

### Phase 10: Extract Pipeline Step Functions
Create individual step functions following uniform functional pattern.

**Key Insight:** Think in terms of composable pipeline steps, not mode-specific functions. Each step is a pure transformation that can opt-in/out via configuration. This sets the foundation for future steps (debayer, hot pixel removal, weighting, astrometric solving) without architectural changes.

**Pattern:** Every step follows the same signature:
```fsharp
stepName: ConfigType option -> InputType -> Result<OutputType, PipelineError>
```
If config is `None`, step returns input unchanged (skip track).

**Actions:**
- Extract `calibrate` step function (already exists, verify it follows pattern)
- Extract `bin` step function (already exists, verify it follows pattern)
- Create `matchStars` step function:
  ```fsharp
  let matchStars
      (config: MatchingConfig option)
      (detected: DetectedImage)
      : Result<MatchedImage option, PipelineError> =
      match config with
      | None -> Ok None  // Skip track - no matching needed
      | Some cfg ->
          Alignment.matchToReference cfg detected.FileName detected
          |> Result.mapError MatchingFailed
          |> Result.map Some
  ```
- Create `applyDistortion` step function:
  ```fsharp
  let applyDistortion
      (config: DistortionConfig option)
      (matched: MatchedImage option)
      : Result<DistortionResult option, PipelineError> =
      match (config, matched) with
      | (None, _) | (_, None) -> Ok None  // Skip track
      | (Some cfg, Some m) ->
          let (_, result) = Alignment.computeDistortion (Some cfg) m
          Ok (Some result)
  ```
- Create `applyTransform` step function:
  ```fsharp
  let applyTransform
      (config: TransformConfig option)
      (matched: MatchedImage option)
      (distortion: DistortionResult option)
      : Result<ImageData option, PipelineError> =
      match (config, matched) with
      | (None, _) | (_, None) -> Ok None  // Skip track
      | (Some cfg, Some m) ->
          let rbfCoeffs = distortion |> Option.bind (fun r -> r.Coefficients)
          Alignment.transform cfg (m, rbfCoeffs)
          |> Result.mapError TransformFailed
          |> Result.map Some
  ```

**Benefits:**
- Each step is pure, testable, composable
- Skip behavior explicit (None → passthrough)
- Future steps follow same pattern
- No mode-specific branching in step functions

**Compile:** ✓ New step functions compile, existing code unchanged

### Phase 11: Create PipelineConfigs Type and Builder
Consolidate configuration into a single type that represents the entire pipeline.

**Key Insight:** Instead of scattering config across multiple parameters, create ONE config type. Mode determines which fields are Some/None. This is the control panel for the pipeline.

**Actions:**
- Create `PipelineConfigs` type:
  ```fsharp
  type PipelineConfigs = {
      Calibration: (MasterFrames * CalibrationConfig) option
      Binning: BinningConfig
      Detection: DetectionConfig
      Matching: MatchingConfig option
      Distortion: DistortionConfig option
      Transform: TransformConfig option
      Output: OutputConfig
      // Future steps slot in here:
      // Debayer: DebayerConfig option
      // HotPixel: HotPixelConfig option
      // Weighting: WeightingConfig option
      // Astrometry: AstrometryConfig option
  }

  type OutputConfig = {
      Mode: OutputMode
      Intensity: float
      Format: XisfSampleFormat option
      IncludeDetectionModel: bool
      IncludeDistortionModel: bool
      ShowDistortionStats: bool
      RefImageDims: int * int
  }
  ```

- Create `buildPipelineConfigs` function:
  ```fsharp
  let buildPipelineConfigs
      (mode: OutputMode)
      (opts: AlignOptions)
      (masters: (MasterFrames * CalibrationConfig) option)
      (refData: ReferenceData)
      : PipelineConfigs =
      {
          Calibration = masters
          Binning = { Factor = opts.BinFactor; Method = opts.BinMethod }
          Detection = {
              Threshold = opts.Threshold
              GridSize = opts.GridSize
              MinFWHM = opts.MinFWHM
              MaxFWHM = opts.MaxFWHM
              MaxEccentricity = opts.MaxEccentricity
              MaxStars = opts.MaxStars
          }
          Matching =
              match mode with
              | Detect -> None
              | _ -> Some {
                  RefStars = refData.Frame.Detected.Stars
                  RefTriangles = refData.Frame.Triangles
                  Params = {
                      Algorithm = opts.Algorithm
                      RatioTolerance = opts.RatioTolerance
                      MaxStarsTriangles = opts.MaxStarsTriangles
                      MinVotes = opts.MinVotes
                      AnchorStars = opts.AnchorStars
                      AnchorDistribution = opts.AnchorDistribution
                  }
              }
          Distortion =
              match (mode, opts.Distortion) with
              | (Align, d) | (Distortion, d) when d <> NoDistortion ->
                  let kernel = match d with
                               | Wendland -> RBFTransform.Wendland 1
                               | TPS -> RBFTransform.ThinPlateSpline
                               | IMQ -> RBFTransform.InverseMultiquadric
                               | NoDistortion -> RBFTransform.Wendland 1
                  Some { Kernel = kernel; SupportFactor = opts.RBFSupportFactor; Regularization = opts.RBFRegularization }
              | _ -> None
          Transform =
              match mode with
              | Align -> Some { Interpolation = opts.Interpolation; ApplyRBF = opts.Distortion <> NoDistortion }
              | _ -> None
          Output = {
              Mode = mode
              Intensity = opts.Intensity
              Format = opts.OutputFormat
              IncludeDetectionModel = opts.IncludeDetectionModel
              IncludeDistortionModel = opts.IncludeDistortionModel
              ShowDistortionStats = opts.ShowDistortionStats
              RefImageDims = (refData.Frame.Detected.Image.Width, refData.Frame.Detected.Image.Height)
          }
      }
  ```

**Benefits:**
- Single source of truth for pipeline configuration
- Mode logic isolated in one builder function
- Future steps just add new fields
- Easy to see what configs are mode-dependent

**Compile:** ✓ New types and builder compile, existing code unchanged

### Phase 12: Create Unified processFile Pipeline
Compose all step functions into single unified pipeline.

**Key Insight:** Now that we have composable step functions and consolidated configs, create ONE `processFile` that works for ALL modes. Steps execute or skip based on config.

**Actions:**
- Create `processFile` function that composes all step functions
- Takes `PipelineConfigs` instead of scattered parameters
- Linear pipeline: load → calibrate → bin → detect → match → distort → transform → output → save
- Each step reads its config from `PipelineConfigs` and skips if `None`
```fsharp
let processFile
    (inputPath: string)
    (outputPath: string)
    (configs: PipelineConfigs)
    : AsyncResult<unit, PipelineError> =

    asyncResult {
        // LOAD
        let! rawImage = loadImage inputPath |> AsyncResult.mapError LoadFailed

        // CALIBRATE (skip if None)
        let! calibrated = calibrate configs.Calibration rawImage |> AsyncResult.ofResult

        // BIN (skip if None)
        let! binned = bin (Some configs.Binning) calibrated |> AsyncResult.ofResult

        // DETECT (always runs)
        let detected = Alignment.detect configs.Detection binned

        // MATCH (skip if None)
        let! matched = matchStars configs.Matching detected |> AsyncResult.ofResult

        // DISTORT (skip if None)
        let! distortion = applyDistortion configs.Distortion matched |> AsyncResult.ofResult

        // TRANSFORM (skip if None)
        let! transformed = applyTransform configs.Transform matched distortion |> AsyncResult.ofResult

        // FUTURE STEPS SLOT IN HERE:
        // let! debayered = debayer configs.Debayer transformed |> AsyncResult.ofResult
        // let! hotPixelsCleaned = removeHotPixels configs.HotPixel debayered |> AsyncResult.ofResult
        // let! weighted = applyWeighting configs.Weighting hotPixelsCleaned |> AsyncResult.ofResult
        // let! solved = astrometricSolve configs.Astrometry weighted |> AsyncResult.ofResult

        // GENERATE OUTPUT (varies by mode)
        let! output = generateOutput configs.Output detected matched distortion transformed |> AsyncResult.ofResult

        // SAVE
        do! writeOutputFile outputPath output |> AsyncResult.mapError SaveFailed

        return ()
    }
```

Then create batch processor:
```fsharp
let processBatch
    (files: string[])
    (opts: AlignOptions)
    (configs: PipelineConfigs)
    : Async<int> =

    async {
        Directory.CreateDirectory opts.Output |> ignore

        let suffix = determineSuffix configs.Output.Mode opts.Suffix

        let tasks = files |> Array.map (fun f ->
            let baseName = Path.GetFileNameWithoutExtension f
            let outPath = Path.Combine(opts.Output, $"{baseName}{suffix}.xisf")
            if File.Exists outPath && not opts.Overwrite then
                async { Log.Warning("..."); return Ok () }
            else
                processFile f outPath configs
        )

        let sw = Stopwatch.StartNew()
        let! results = Async.Parallel(tasks, maxDegreeOfParallelism = opts.MaxParallel)
        sw.Stop()

        let successCount = results |> Array.filter Result.isOk |> Array.length
        results |> Array.iter (Result.iterError (fun err -> Log.Error($"{err}")))
        printfn ""
        printfn $"Processed {successCount}/{files.Length} in {sw.Elapsed.TotalSeconds:F1}s"

        return if successCount < files.Length then 1 else 0
    }
```

**Benefits:**
- ONE pipeline for ALL modes
- Steps clearly ordered, easy to add new ones
- No mode branching in processFile - config determines behavior
- Future-proof architecture

**Compile:** ✓ Unified pipeline compiles

### Phase 13: Flatten Run Function
Wire the unified pipeline into a flat run function.

**Key Insight:** The run function does TWO things: (1) setup/validation → (2) batch processing. Use asyncResult for setup, then call processBatch.

**Actions:**
- Flatten validation/setup using `asyncResult` CE
- Build `PipelineConfigs` using the builder function
- Call `processBatch` with configs
- Single `match!` handles all setup errors

**Structure:**
```fsharp
let run (args: string array) =
    if args |> Array.exists (fun a -> a = "--help" || a = "-h") then
        showHelp()
        0
    else
        let setupResult = asyncResult {
            // Parse
            let opts = parseArgs args

            // Validate
            do! validateAlignOptions opts |> Result.mapError ValidationFailed
            do! validateCalibrationConfig opts |> Result.mapError CalibrationValidationFailed

            // Resolve input files
            let! files = InputValidation.resolveInputFiles opts.Input
                         |> Result.mapError InputResolutionFailed
            printfn $"Found {files.Length} files"
            printfn ""

            // Load masters and analyze reference
            let! masters = loadCalibrationMasters opts |> AsyncResult.mapError MasterLoadFailed
            let binConfig = { Factor = opts.BinFactor; Method = opts.BinMethod }
            let detConfig = { Threshold = opts.Threshold; GridSize = opts.GridSize; (* ... *) }

            let refFile = resolveReferenceFile files opts
            printfn $"Reference: {Path.GetFileName refFile}"
            let! refData = analyzeReference refFile masters binConfig detConfig opts.MaxStarsTriangles
                           |> AsyncResult.mapError ReferenceAnalysisFailed

            do! validateReferenceStars refData.Frame.Detected.Stars.Length
                |> Result.mapError (fun _ -> InsufficientStars (refData.Frame.Detected.Stars.Length, 10))

            printfn $"Reference stars detected: {refData.Frame.Detected.Stars.Length}"
            printfn $"Reference triangles formed: {refData.Frame.Triangles.Length}"
            printfn ""

            // Build pipeline config
            let pipelineConfigs = buildPipelineConfigs opts.OutputMode opts masters refData

            return (opts, files, pipelineConfigs)
        }

        async {
            match! setupResult with
            | Error err ->
                Log.Error(err.ToString())
                printfn ""
                printfn "Run 'xisfprep align --help' for usage information"
                return 1
            | Ok (opts, files, configs) ->
                let! exitCode = processBatch files opts configs
                return exitCode
        }
        |> Async.RunSynchronously
```

**Benefits:**
- Setup is flat (no nested matches)
- Single point of config creation
- No mode routing in run - just build config and call batch
- Clear separation: validate → configure → execute

**Compile:** ✓ Run function completely flattened

**Success Criteria:**
- ✅ No more than 1 level of nesting in setup (asyncResult block)
- ✅ Single `match!` handles all validation errors
- ✅ No mode-specific branches in run
- ✅ Pipeline configuration isolated in builder function
- ✅ Clear, linear reading flow
