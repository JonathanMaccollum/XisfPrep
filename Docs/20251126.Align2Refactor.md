# Align2 Refactoring Plan: Extract Algorithms.Alignment Module

**Date**: 2025-11-26
**Objective**: Extract core alignment algorithm from Commands.Align2 into reusable Algorithms.Alignment module

## Overview

Align2.fs currently contains both alignment algorithm logic and command orchestration. This refactoring extracts the alignment-specific algorithm (detection → matching → distortion → transformation) into a dedicated module while leaving preprocessing (calibration, binning) and orchestration (I/O, CLI, batch processing) in the command.

**Key Principle**: Alignment algorithms orchestrate alignment steps. Commands orchestrate preprocessing + alignment + I/O.

## Responsibility Separation

### Algorithms.Alignment (NEW MODULE)

**Scope**: Image registration algorithm only

**Responsibilities**:
- Star detection
- Star matching (triangle or expanding)
- Distortion correction (RBF)
- Image transformation
- Orchestrate these four alignment stages into a pipeline

**Does NOT Handle**:
- Calibration (bias/dark/flat)
- Binning
- File I/O
- XISF format
- CLI arguments
- Batch processing
- Visualization/output generation

**Input**: Preprocessed ImageData (already calibrated, already binned)
**Output**: Aligned ImageData (registered to reference frame)

### Commands.Align2 (EXISTING MODULE - REFACTORED)

**Scope**: Full pipeline orchestration + user interface

**Responsibilities**:
- Preprocessing: calibration → binning
- Call Algorithms.Alignment with preprocessed images
- File I/O: load XISF, write XISF
- CLI: argument parsing, validation, help
- Batch processing: parallel execution
- Output modes: detect, match, align, distortion
- Visualization: generate diagnostic images

**Pipeline Flow**:
```
Raw XISF → Calibrate → Bin → [Alignment Module] → Output XISF
                                      ↓
                           detect → match → distort → transform
```

## Target Architecture

### Module Organization

```
Algorithms.Alignment.fs (NEW)
├── Types
│   ├── ImageData
│   ├── DetectedImage
│   ├── MatchedImage
│   ├── DistortionResult
│   ├── ReferenceFrame
│   ├── DetectionConfig
│   ├── MatchingConfig
│   ├── DistortionConfig
│   ├── TransformConfig
│   └── AlignmentConfig
├── Pipeline Stages
│   ├── detect
│   ├── matchToReference
│   ├── computeDistortion
│   └── transform
└── High-Level API
    ├── prepareReference
    └── align

Commands.Align2.fs (REFACTORED)
├── Types (Command-specific only)
│   ├── AlignOptions
│   ├── AlignValidationError
│   ├── ReferenceData
│   └── ProcessingResult
├── Preprocessing
│   └── preprocessImage
├── Reference Preparation
│   └── analyzeReference
├── Output Generation
│   ├── generateDetectOutput
│   ├── generateMatchOutput
│   ├── generateAlignOutput
│   └── createOutputImage
├── Batch Processing
│   ├── processDetectMode
│   ├── processAlignMode
│   ├── processMatchMode
│   └── processDistortionMode
├── CLI
│   ├── parseArgs
│   ├── validateAlignOptions
│   └── showHelp
└── Entry Point
    └── run
```

### Type Ownership (No Duplication)

| Type | Owned By | Reason |
|------|----------|--------|
| ImageData | Algorithms.Alignment | Core alignment data structure |
| DetectedImage | Algorithms.Alignment | Alignment pipeline stage |
| MatchedImage | Algorithms.Alignment | Alignment pipeline stage |
| DistortionResult | Algorithms.Alignment | Alignment pipeline stage |
| ReferenceFrame | Algorithms.Alignment | Prepared reference for alignment |
| DetectionConfig | Algorithms.Alignment | Alignment configuration |
| MatchingConfig | Algorithms.Alignment | Alignment configuration |
| DistortionConfig | Algorithms.Alignment | Alignment configuration |
| TransformConfig | Algorithms.Alignment | Alignment configuration |
| AlignmentConfig | Algorithms.Alignment | Unified alignment configuration |
| AlignOptions | Commands.Align2 | CLI arguments |
| AlignValidationError | Commands.Align2 | CLI validation |
| ReferenceData | Commands.Align2 | Reference metadata + preprocessed frame |
| ProcessingResult | Commands.Align2 | Batch processing results |
| OutputMode | Commands.Align2 | CLI output mode selection |

## Orchestration Pattern (Command Level)

**Commands.Align2 orchestrates the full pipeline:**

```
PREPROCESSING PHASE (Command's responsibility):
  loadImage(path)
    ↓
  applyCalibration(pixels, masters)  ← Calls Algorithms.Calibration
    ↓
  applyBinning(pixels, factor)       ← Calls Algorithms.Binning
    ↓
  ImageData (preprocessed)

ALIGNMENT PHASE (Delegate to Algorithms.Alignment):
  Alignment.align(reference, target, config)
    ↓
  ImageData (aligned)

OUTPUT PHASE (Command's responsibility):
  createOutputImage(aligned, headers)
    ↓
  writeOutputFile(path, image)
```

**Command Flow (Pseudocode)**:
```
function processAlignMode(inputPath, outputPath, reference, opts):
    // PREPROCESSING
    raw = loadImage(inputPath)
    calibrated = Calibration.applyCalibration(raw.pixels, opts.masters)
    binned = Binning.binImage(calibrated, opts.binFactor)
    preprocessed = ImageData(binned, width, height, channels)

    // ALIGNMENT (delegate)
    alignConfig = buildAlignmentConfig(opts)
    aligned = Alignment.align(reference.frame, preprocessed, alignConfig)

    // OUTPUT
    output = createOutputImage(aligned, generateHeaders(...))
    writeOutputFile(outputPath, output)
```

## Composition Pattern (Alignment Module)

**Algorithms.Alignment composes alignment-specific algorithms:**

```
REFERENCE PREPARATION:
  ImageData (preprocessed)
    ↓
  StarDetection.detectStars(pixels, ...) ← Calls Algorithms.StarDetection
    ↓
  DetectedImage
    ↓
  TriangleMatch.formTriangles(stars, ...) ← Calls Algorithms.TriangleMatch
    ↓
  ReferenceFrame

ALIGNMENT PIPELINE:
  ImageData (target, preprocessed)
    ↓
  detect(config, image)
    ↓
  DetectedImage
    ↓
  matchToReference(config, refStars, refTriangles, detected)
    ↓
  MatchedImage
    ↓
  computeDistortion(config, matched)
    ↓
  DistortionResult
    ↓
  transform(config, matched, distortion)
    ↓
  ImageData (aligned)
```

**Alignment Composition (Pseudocode)**:
```
function align(reference: ReferenceFrame, target: ImageData, config: AlignmentConfig):
    // DETECT
    detected = detect(config.detection, target)
    if detected.stars.length < 10:
        return Error("Insufficient stars")

    // MATCH
    matched = matchToReference(config.matching, reference.stars, reference.triangles, detected)
    if matched is None:
        return Error("Match failed")

    // DISTORT
    distortion = computeDistortion(config.distortion, matched)

    // TRANSFORM
    aligned = transform(config.transform, matched, distortion)

    return Ok(aligned)
```

**Each stage delegates to existing modules:**
- `detect` → calls `StarDetection.detectStars`
- `matchToReference` → calls `TriangleMatch.matchTriangles` or `SpatialMatch.expandingMatch`
- `computeDistortion` → calls `RBFTransform.computeRBF`
- `transform` → calls `Interpolation.resample` + `RBFTransform.applyRBF`

## Acceptance Criteria

### Functional Requirements

1. **Full Feature Parity**: All features in current Align2.fs work identically
   - All four output modes: detect, match, align, distortion
   - All matching algorithms: triangle, expanding
   - All distortion kernels: none, wendland, tps, imq
   - All interpolation methods: nearest, bilinear, bicubic, lanczos3
   - Calibration integration (bias, dark, flat)
   - Binning integration (2x-6x, average/median/sum)
   - Diagnostic outputs: detection model, distortion model
   - Performance timing and statistics

2. **Zero Regressions**: No bugs introduced
   - Output images byte-identical to pre-refactor version
   - Same error handling behavior
   - Same performance characteristics

3. **User Transparency**: End users see no difference
   - Same command-line interface
   - Same argument parsing
   - Same console output
   - Same FITS headers
   - Same file naming

### Code Quality Requirements

4. **No Dead Code**: Align2.fs contains no unused functions or types
   - Every function in Align2.fs is called from run or batch processors
   - Every type in Align2.fs is used by command orchestration
   - All alignment algorithm code moved to Algorithms.Alignment

5. **No Duplication**: Each type defined in exactly one place
   - No duplicate type definitions between modules
   - No copied functions (only moved)
   - Shared types imported via `open` or fully qualified names

6. **No Unnecessary Comments**: Code is self-documenting
   - Type and function names clearly indicate purpose
   - Only doc comments (///) for public API
   - No "TODO", "FIXME", or explanatory comments needed

### Compilation Requirements

7. **Builds After Every Step**: Each surgical move compiles
   - Run `dotnet build` after every function/type move
   - Fix compilation errors before proceeding to next step
   - No "move everything then fix" approach

8. **All Tests Pass**: Existing tests continue to pass
   - No test modifications required (tests use public API)
   - Add new tests for Algorithms.Alignment public API
   - Integration tests verify full pipeline still works

## Surgical Migration Steps

### ✅ Phase 1 & 2: Module Setup and Type Migration (COMPLETE)

**Completed**: Created `Algorithms.Alignment` module and migrated all alignment-specific types.

**Types moved to Alignment.fs**:
- Pipeline stage types: `ImageData`, `DetectedImage`, `MatchedImage`, `DistortionResult`
- Configuration types: `DetectionConfig`, `MatchingConfig`, `DistortionConfig`, `TransformConfig`, `AlignmentConfig`
- Algorithm enum: `MatchAlgorithm`

**Verified**:
- File ordering correct in XisfPrep.fsproj (Alignment.fs before Align2.fs)
- Align2.fs correctly imports `Algorithms.Alignment`
- Zero duplicate type definitions
- Build succeeds with zero warnings
- Command-specific types properly remain in Align2.fs: `AlignOptions`, `AlignValidationError`, `ReferenceData`, `ProcessingResult`, `BinningConfig`, `OutputMode`, `DistortionCorrection`

### ✅ Phase 3: Pipeline Functions Migration (COMPLETE)

**Completed**: Moved all four core alignment pipeline functions to Algorithms.Alignment.

**Functions moved**:
- `detect` - Star detection with MAD calculation and channel extraction
- `matchToReference` - Star matching supporting both Triangle and Expanding algorithms
- `computeDistortion` - Optional RBF distortion correction with statistics
- `transform` - Geometric transformation with optional RBF and parallel processing

**Verified**:
- All functions removed from Align2.fs (no duplicates)
- Align2.fs correctly delegates to Alignment module
- Both matching algorithms (Triangle, Expanding) fully functional
- Diagnostics generation preserved for both algorithms
- Parallel processing preserved in transform
- Feature parity with Align.fs maintained (100%)
- Build succeeds with zero warnings

**Key architectural wins**:
- Alignment module has no I/O, no file system, no XISF dependencies
- Preprocessing (calibrate, bin) correctly remains in Align2.fs
- Pipeline orchestration (detectPipeline, alignPipeline) correctly remains in Align2.fs
- Clear separation: Alignment = algorithm, Command = orchestration + I/O

### ✅ Phase 4: High-Level API (COMPLETE)

**Completed**: Added high-level orchestration functions to Algorithms.Alignment.

**Added**:
- `ReferenceFrame` type - Encapsulates prepared reference (DetectedImage + triangles)
- `prepareReference` function - Prepares reference frame for alignment
- `align` function - Full pipeline orchestration (detect → match → distort → transform)

**Verified**:
- All functions compile successfully
- Proper Result-based error handling
- Complete pipeline orchestration implemented
- Build succeeds with zero warnings

**Design Notes**:
- Functions not yet used in Align2.fs (will be integrated in Phase 5)
- Minor observation: `prepareReference` hard-codes maxStarsTriangles=100 (should be parameterized before Phase 5)
- MatchingConfig has dual purpose (low-level + high-level) causing minor redundancy in AlignmentConfig (works correctly, just less elegant)

### ✅ Phase 5: Commands.Align2 Refactoring (COMPLETE)

**Completed**: Refactored all Commands.Align2 orchestration to use Algorithms.Alignment module.

**Step 5.1 - preprocessImage function** ✅:
- Created clean preprocessing pipeline: `calibrate` → `bin`
- Returns preprocessed ImageData ready for alignment
- Maintains separation: preprocessing (Command) vs alignment (Algorithm)

**Step 5.2 - analyzeReference refactoring** ✅:
- Refactored to use `preprocessImage` + `Alignment.prepareReference`
- **ReferenceData type simplified**: 9 fields → 3 fields
  - Before: Stars, Triangles, Width, Height, Channels, FileName, DetectionParams
  - After: Frame (ReferenceFrame), FileName, DetectionParams
- Complete cascading update: 15+ call sites updated to use nested access
  - `refData.Stars` → `refData.Frame.Detected.Stars`
  - `refData.Triangles` → `refData.Frame.Triangles`
  - `refData.Width` → `refData.Frame.Detected.Image.Width`
  - `refData.Height` → `refData.Frame.Detected.Image.Height`

**Steps 5.3-5.6 - Batch processing functions** ✅:
All four batch processors refactored to use Alignment module:
- `processDetectMode`: uses `Alignment.detect`
- `processAlignMode`: uses full pipeline (`detect` → `matchToReference` → `computeDistortion` → `transform`)
- `processMatchMode`: uses `detect` → `matchToReference`
- `processDistortionMode`: uses `detect` → `matchToReference` → `computeDistortion`

**Step 5.7 - prepareReference parameterization** ✅:
- Fixed hardcoded `maxStarsTriangles = 100`
- Updated signature: `prepareReference (config: DetectionConfig) (maxStarsTriangles: int) (refImage: ImageData)`
- All call sites updated to pass `opts.MaxStarsTriangles`

**Verified**:
- Build succeeds with zero warnings/errors
- All batch processing functions use Alignment module
- Clean separation: Command handles preprocessing + I/O, Alignment handles algorithm
- No feature regressions
- Type safety maintained throughout
- `calibrate` and `bin` correctly remain in Align2.fs (preprocessing helpers, not alignment)

### ✅ Phase 6: Remove Dead Code (COMPLETE)

**Completed**: All dead code removed from Commands.Align2.

**Dead code removed**:
- ✅ `open Algorithms.Statistics` - unused import
- ✅ `detectPipeline` function (48 lines) - replaced by direct Alignment.detect calls in batch processors
- ✅ `alignPipeline` function (19 lines) - replaced by direct Alignment function calls
- ✅ `bind` helper (4 lines) - unused railway composition helper
- ✅ `liftAsync` helper (1 line) - unused async lift helper
- ✅ `processImageFile` function (35 lines) - example function never called (TO BE REMOVED)

**Comments cleaned**:
- ✅ Removed "Temporary location, will be moved later" from ARGUMENT PARSING section
- ✅ No TODO/FIXME comments remain

**Functions correctly retained** (NOT dead code):
- ✅ `calibrate` - Preprocessing helper, used by preprocessImage and batch processors
- ✅ `bin` - Preprocessing helper, used by preprocessImage and batch processors
- ✅ `preprocessImage` - Orchestration function, used by analyzeReference and batch processors
- ✅ `BinningConfig` type - Command-specific config, wraps Binning.BinningMethod

**Verified**:
- Build succeeds with zero warnings/errors
- No duplicate type definitions
- All retained functions actively used
- Clean module boundaries maintained

**Remaining cleanup**:
- ❌ Remove `processImageFile` example function (lines 571-605)

### Phase 7: Optional Improvements (FUTURE)

**Note**: This phase is optional and can be deferred. It addresses design awkwardness but does not affect functionality.

**Problem**: MatchingConfig serves dual purpose, creating redundancy:
1. **Low-level use**: `matchToReference` function needs `RefStars` and `RefTriangles`
2. **High-level use**: Embedded in `AlignmentConfig`, but `RefStars`/`RefTriangles` are redundant with `ReferenceFrame`

**Current awkwardness** (in `Alignment.align` function):
```
let matchConfig: MatchingConfig = {
    RefStars = reference.Detected.Stars        // From ReferenceFrame
    RefTriangles = reference.Triangles         // From ReferenceFrame
    Algorithm = config.Matching.Algorithm      // From AlignmentConfig
    RatioTolerance = config.Matching.RatioTolerance
    // ... other fields extracted from config.Matching
}
```

The `config.Matching.RefStars` and `config.Matching.RefTriangles` are ignored and overridden.

**Step 7.1**: Create MatchingParams type
- Add new type without reference data:
```
type MatchingParams = {
    Algorithm: MatchAlgorithm
    RatioTolerance: float
    MaxStarsTriangles: int
    MinVotes: int
    AnchorStars: int
    AnchorDistribution: SpatialMatch.AnchorDistribution
}
```

**Step 7.2**: Refactor MatchingConfig
- Update MatchingConfig to use MatchingParams:
```
type MatchingConfig = {
    RefStars: DetectedStar[]
    RefTriangles: Triangle[]
    Params: MatchingParams
}
```
- Or keep MatchingConfig as-is for backward compatibility

**Step 7.3**: Update AlignmentConfig
- Replace `Matching: MatchingConfig` with `Matching: MatchingParams`
- This eliminates redundancy with ReferenceFrame

**Step 7.4**: Update align function
- Simplify construction - no more extracting fields:
```
let matchConfig: MatchingConfig = {
    RefStars = reference.Detected.Stars
    RefTriangles = reference.Triangles
    Params = config.Matching  // Direct assignment, no field extraction
}
```

**Step 7.5**: Update all call sites
- Update Align2.fs to use MatchingParams where appropriate
- Verify: `dotnet build`

**Benefits**:
- Clearer separation of concerns
- No redundant fields in AlignmentConfig
- More intuitive API design
- Easier to understand configuration structure

**Trade-offs**:
- Additional type complexity
- More refactoring work
- Current design works correctly

**Recommendation**: Defer to post-MVP. Current design is functional, this is a polish improvement.

## Verification Checklist

After completing all steps, verify:

### Compilation
- [ ] `dotnet build` succeeds with zero warnings
- [ ] No duplicate type definitions
- [ ] All imports resolved

### Functionality
- [ ] Run align command on test dataset
- [ ] Compare output with pre-refactor version (should be identical)
- [ ] Test all output modes: detect, match, align, distortion
- [ ] Test all matching algorithms: triangle, expanding
- [ ] Test with calibration enabled
- [ ] Test with binning enabled
- [ ] Test diagnostic outputs: --include-detection-model, --include-distortion-model
- [ ] Test distortion modes: wendland, tps, imq
- [ ] Test batch processing with --parallel

### Code Quality
- [ ] No unused functions in Align2.fs
- [ ] No unused types in Align2.fs
- [ ] No duplicate type definitions
- [ ] No copied code (only moved)
- [ ] No dead imports
- [ ] No unnecessary comments
- [ ] All public functions documented with ///

### Module Boundaries
- [ ] Algorithms.Alignment has no file I/O
- [ ] Algorithms.Alignment has no CLI dependencies
- [ ] Algorithms.Alignment has no XISF dependencies
- [ ] Algorithms.Alignment has no calibration/binning code
- [ ] Commands.Align2 has no alignment algorithm implementation
- [ ] Commands.Align2 delegates all alignment to Algorithms.Alignment

### User Experience
- [ ] Command-line arguments unchanged
- [ ] Help output unchanged
- [ ] Console output format unchanged
- [ ] FITS headers identical
- [ ] File naming conventions unchanged
- [ ] Error messages unchanged
- [ ] Performance characteristics similar

## Success Criteria Summary

**The refactoring is complete when:**

1. Algorithms.Alignment module exists and compiles
2. Algorithms.Alignment contains all alignment-specific types and functions
3. Commands.Align2 delegates all alignment to Algorithms.Alignment
4. Commands.Align2 handles only preprocessing, I/O, CLI, and batch orchestration
5. No duplicate type definitions exist
6. No dead code remains in either module
7. All tests pass
8. End users cannot detect any difference in behavior
9. Output files are byte-identical to pre-refactor version
10. Code is cleaner, more maintainable, and properly encapsulated
